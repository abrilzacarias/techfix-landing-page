---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
const features = [
  {
    title: "Gestión de turnos",
    description: "Organice sus reparaciones con un calendario que permite asignar tareas y agendar citas fácilmente.",
    icon: "M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2",
    color: "primary"
  },
  {
    title: "Historial de reparaciones",
    description: "Accede al historial completo de cada cliente y dispositivo para brindar un servicio más personalizado.",
    icon: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z",
    color: "secondary"
  },
  {
    title: "Notificaciones automáticas",
    description: "Mantenga informados a sus clientes con avisos automáticos por correo electrónico.",
    icon: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z",
    color: "accent"
  },
  {
    title: "Inventario inteligente",
    description: "Controle el stock de repuestos con alertas automáticas para reposición y seguimiento por proveedor.",
    icon: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15",
    color: "warning"
  },
  {
    title: "Asignación de Roles",
    description: "Organice y delegue tareas con facilidad asignando roles a empleados según sus responsabilidades.",
    icon: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z",
    color: "primary"
  },
  {
    title: "Control de Gastos Operativos",
    description: "Monitoree y controle los gastos operativos de su negocio, asegurando una gestión financiera eficiente.",
    icon: "M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z",
    color: "secondary"
  }
];
---

<Layout title="Features - Impressive Animations & Experiences">
  <Header />
  <main>
    <!-- Hero Section -->
    <section class="relative overflow-hidden bg-linear-to-b from-primary-100 to-white dark:from-primary-950 dark:to-secondary-950 pt-24 md:pt-32 pb-16 md:pb-20">
      <div class="absolute inset-0 z-0 opacity-30">
        <div class="absolute inset-0 bg-grid-pattern"></div>
      </div>
      
      <div class="container-custom relative z-10">
        <div class="text-center max-w-3xl mx-auto px-4">
          <h1 class="text-3xl md:text-4xl lg:text-5xl mb-4 md:mb-6 text-gray-900 dark:text-white animate-slide-down">
            Grandes <span class="text-primary-600 dark:text-primary-500">funcionalidades</span>
          </h1>
          <p class="text-lg md:text-xl text-gray-700 dark:text-gray-300 mb-6 md:mb-8 animate-slide-up" style="animation-delay: 200ms">
            Descubre todas las herramientas que Techfix tiene disponibles.
          </p>
        </div>
      </div>
      
      <!-- Animated Shapes -->
      <div class="absolute -bottom-16 left-0 right-0 flex justify-center">
        <div class="w-48 md:w-64 h-48 md:h-64 bg-secondary-200 rounded-full filter blur-3xl opacity-20 animate-pulse"></div>
      </div>
      
    </section>

    <section id="features" class="section bg-gray-50 dark:bg-gray-800/50 relative overflow-hidden">
      <div class="container-custom relative z-10">
        <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
          {features.map((feature, index) => (
            <div 
              class="feature-card perspective" 
              data-aos="fade-up"
              data-aos-delay={index * 100}
            >
              <div class="card hover-card p-6 border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 rounded-lg transition-all duration-300">
                <div class="icon-wrapper">
                  <div class={`w-12 h-12 rounded-lg bg-${feature.color}-100 dark:bg-${feature.color}-900/30 flex items-center justify-center mb-6 icon-animate`}>
                    <svg 
                      class={`w-6 h-6 text-${feature.color}-600 dark:text-${feature.color}-400`} 
                      fill="none" 
                      stroke="currentColor" 
                      viewBox="0 0 24 24" 
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d={feature.icon}></path>
                    </svg>
                  </div>
                </div>
                <h3 class="text-xl font-semibold mb-3 text-gray-900 dark:text-white">{feature.title}</h3>
                <p class="text-gray-600 dark:text-gray-300">{feature.description}</p>
                
                <div class="card-shine"></div>
              </div>
            </div>
          ))}
        </div>
      </section>
  </main>
  <Footer />
</Layout>

<style>
  /* Grid Pattern Background */
  .bg-grid-pattern {
    background-image: 
      linear-gradient(to right, rgba(99, 102, 241, 0.1) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(99, 102, 241, 0.1) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  /* 3D Card Transformations */
  .perspective {
    perspective: 1000px;
  }
  
  .preserve-3d {
    transform-style: preserve-3d;
  }
  
  .backface-hidden {
    backface-visibility: hidden;
  }
  
  .rotate-y-180 {
    transform: rotateY(180deg);
  }
  
  /* Touch device support for 3D cards */
  @media (hover: none) {
    .touch-action-card {
      transition: none;
    }
    
    .touch-action-card:active {
      transform: rotateY(180deg);
    }
  }

  /* Parallax Effect */
  .parallax-container {
    overflow: hidden;
  }
  
  .parallax-demo {
    transform-style: preserve-3d;
    perspective: 1000px;
  }
  
  .parallax-layer {
    will-change: transform;
    transition: transform 0.1s ease-out;
  }
  
  .layer-1 {
    transform: translateZ(-10px) scale(2);
  }
  
  .layer-2 {
    transform: translateZ(0);
  }
  
  .layer-3 {
    transform: translateZ(10px) scale(0.9);
  }

  /* Particle Animation */
  .particles-container:hover .particles,
  .particles-container:active .particles {
    opacity: 1;
  }
  
  .particles {
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  /* Feature Row Animation */
  .feature-row {
    transition: all 0.3s ease;
  }
  
  .feature-row:hover {
    background-color: rgba(99, 102, 241, 0.05);
  }

  /* Interactive Demo */
  .interactive-demo {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    max-width: 100%;
  }
  
  .interactive-demo:hover {
    transform: translateY(-5px);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  }
  
  /* Mobile optimizations */
  @media (max-width: 640px) {
    .interactive-demo:hover {
      transform: none;
    }
    
    .comparison-table {
      font-size: 0.875rem;
    }
    
    /* 修复卡片在小屏幕上的高度和定位问题 */
    .feature-card {
      position: relative;
      min-height: 280px;
      margin-bottom: 2rem;
      clear: both;
      display: block;
    }
    
    /* 确保3D卡片在翻转时内容不会溢出 */
    .preserve-3d {
      min-height: 280px;
    }
    
    /* 确保卡片内容不会重叠 */
    .card {
      height: 100%;
      position: relative;
      overflow: visible;
    }
    
    /* 修复平行滚动演示在移动设备上的显示 */
    .parallax-demo {
      height: 160px;
      margin-top: 1rem;
    }
    
    /* 确保标题和文本不会重叠 */
    h3 {
      position: relative;
      z-index: 5;
    }
  }
  
  /* 修复触摸设备上的3D卡片翻转问题 */
  @media (hover: none) {
    .touch-action-card {
      transition: transform 0.5s ease;
    }
    
    /* 确保卡片在移动设备上有足够的空间 */
    .feature-card.perspective {
      margin-bottom: 2.5rem;
    }
    
    /* 确保卡片内容在移动设备上不会重叠 */
    .feature-card.perspective .card {
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
  }
  
  /* 确保网格布局在移动设备上正确显示 */
  .grid {
    display: grid;
    grid-template-columns: repeat(1, minmax(0, 1fr));
  }
  
  @media (min-width: 768px) {
    .grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
  
  @media (min-width: 1024px) {
    .grid {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
  }

  <style>
  /* Grid Pattern Background */
  .bg-grid-pattern {
    background-image: 
      linear-gradient(to right, rgba(99, 102, 241, 0.1) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(99, 102, 241, 0.1) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  /* Animación de entrada para el título y descripción */
  .fade-in-up {
    animation: fadeInUp 0.8s ease-out forwards;
  }
  
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Animación para las tarjetas */
  .hover-card {
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    transform: translateY(0);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  }
  
  .hover-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  }
  
  /* Efecto de brillo al pasar el cursor */
  .card-shine {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.1) 50%,
      rgba(255, 255, 255, 0) 100%
    );
    z-index: 1;
    transform: translateX(-100%);
    transition: transform 0.6s;
  }
  
  .hover-card:hover .card-shine {
    transform: translateX(100%);
  }
  
  /* Animación para los iconos */
  .icon-animate {
    transition: all 0.3s ease;
  }
  
  .hover-card:hover .icon-animate {
    transform: scale(1.1) rotate(5deg);
  }
  
  /* Animación para las partículas flotantes */
  @keyframes float {
    0% {
      transform: translate(0, 0);
    }
    25% {
      transform: translate(10px, 10px);
    }
    50% {
      transform: translate(20px, 0);
    }
    75% {
      transform: translate(10px, -10px);
    }
    100% {
      transform: translate(0, 0);
    }
  }
  
  .particles {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0.6;
  }
  
  /* Animación para el botón */
  .pulse-button {
    position: relative;
    transition: all 0.3s ease;
    overflow: hidden;
  }
  
  .pulse-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  }
  
  .pulse-button:hover .arrow-icon {
    animation: bounceX 1s infinite;
  }
  
  @keyframes bounceX {
    0%, 100% {
      transform: translateX(0);
    }
    50% {
      transform: translateX(5px);
    }
  }
  
  /* Animación de aparición para las tarjetas */
  [data-aos="fade-up"] {
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  [data-aos="fade-up"].aos-animate {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Animación para el fondo de las tarjetas */
  @keyframes gradientShift {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .hover-card:hover {
      transform: translateY(-3px);
    }
  }
</style>

<script>
  // Inicializar las animaciones cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    initializeAOS();
    initializeHoverEffects();
    initializeParticles();
  });
  
  // También inicializar cuando se navega con las transiciones de Astro
  document.addEventListener('astro:page-load', () => {
    initializeAOS();
    initializeHoverEffects();
    initializeParticles();
  });
  
  // Inicializar animaciones de aparición
  function initializeAOS() {
    const elements = document.querySelectorAll('[data-aos]');
    
    // Función para verificar si un elemento está en el viewport
    function isInViewport(element) {
      const rect = element.getBoundingClientRect();
      return (
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) * 0.9 &&
        rect.bottom >= 0
      );
    }
    
    // Función para animar elementos cuando son visibles
    function checkVisibility() {
      elements.forEach(element => {
        if (isInViewport(element)) {
          element.classList.add('aos-animate');
        }
      });
    }
    
    // Verificar visibilidad inicial
    setTimeout(checkVisibility, 100);
    
    // Verificar visibilidad al hacer scroll
    window.addEventListener('scroll', checkVisibility);
  }
  
  // Inicializar efectos de hover para tarjetas
  function initializeHoverEffects() {
    const cards = document.querySelectorAll('.hover-card');
    
    cards.forEach(card => {
      // Efecto de seguimiento del cursor para el brillo
      card.addEventListener('mousemove', (e) => {
        const rect = card.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Actualizar la posición del brillo basado en la posición del cursor
        card.style.setProperty('--mouse-x', `${x}px`);
        card.style.setProperty('--mouse-y', `${y}px`);
      });
    });
  }
  
  // Inicializar animación de partículas
  function initializeParticles() {
    const particles = document.querySelectorAll('.particle');
    
    // Asegurarse de que las partículas tengan posiciones y animaciones aleatorias
    particles.forEach(particle => {
      // Asignar posiciones iniciales aleatorias
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      particle.style.left = `${x}%`;
      particle.style.top = `${y}%`;
      
      // Asignar tamaños aleatorios
      const size = Math.random() * 8 + 4;
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      
      // Asignar opacidad aleatoria
      particle.style.opacity = (Math.random() * 0.5 + 0.1).toString();
      
      // Asignar duración y retraso aleatorios para la animación
      const duration = Math.random() * 10 + 15;
      const delay = -Math.random() * 15;
      particle.style.animationDuration = `${duration}s`;
      particle.style.animationDelay = `${delay}s`;
    });
  }
</script>
</style>

<script>
  // Store references to event listeners for cleanup
  const cleanupFunctions: Array<() => void> = [];

  // Function to initialize all interactive features
  function initializeFeatures() {
    // Initialize Parallax Effect
    initializeParallax();
    
    // Initialize Particle Animation
    initializeParticles();
    
    // Initialize Interactive Demo Canvas
    initializeCanvas();
    
    // Initialize touch support for 3D cards
    initializeTouchCards();
  }
  
  // Add touch support for 3D cards
  function initializeTouchCards() {
    const cards = document.querySelectorAll('.feature-card.perspective');
    
    cards.forEach(card => {
      const cardInner = card.querySelector('.preserve-3d');
      
      if (cardInner) {
        // 使用点击事件而不是touchstart，这样更可靠
        const handleClick = () => {
          if (window.matchMedia('(hover: none)').matches) {
            cardInner.classList.toggle('rotate-y-180');
          }
        };
        
        cardInner.addEventListener('click', handleClick);
        
        // Add cleanup function
        cleanupFunctions.push(() => {
          if (cardInner) {
            cardInner.removeEventListener('click', handleClick);
          }
        });
      }
    });
  }

  // Parallax Effect
  function initializeParallax() {
    const parallaxContainer = document.querySelector('.parallax-demo');
    if (parallaxContainer) {
      const layers = parallaxContainer.querySelectorAll('.parallax-layer');
      
      const handleMouseMove = (e: MouseEvent) => {
        const containerRect = parallaxContainer.getBoundingClientRect();
        const relX = e.clientX - containerRect.left;
        const relY = e.clientY - containerRect.top;
        
        const xPercent = relX / containerRect.width - 0.5;
        const yPercent = relY / containerRect.height - 0.5;
        
        layers.forEach((layer, index) => {
          const depth = index * 10;
          const moveX = xPercent * depth;
          const moveY = yPercent * depth;
          
          (layer as HTMLElement).style.transform = `translate3d(${moveX}px, ${moveY}px, 0)`;
        });
      };
      
      const handleTouchMove = (e: TouchEvent) => {
        if (e.touches.length > 0) {
          const containerRect = parallaxContainer.getBoundingClientRect();
          const touch = e.touches[0];
          const relX = touch.clientX - containerRect.left;
          const relY = touch.clientY - containerRect.top;
          
          const xPercent = relX / containerRect.width - 0.5;
          const yPercent = relY / containerRect.height - 0.5;
          
          layers.forEach((layer, index) => {
            const depth = index * 10;
            const moveX = xPercent * depth;
            const moveY = yPercent * depth;
            
            (layer as HTMLElement).style.transform = `translate3d(${moveX}px, ${moveY}px, 0)`;
          });
        }
      };
      
      const handleMouseLeave = () => {
        layers.forEach((layer) => {
          (layer as HTMLElement).style.transform = 'translate3d(0, 0, 0)';
        });
      };
      
      const handleTouchEnd = () => {
        layers.forEach((layer) => {
          (layer as HTMLElement).style.transform = 'translate3d(0, 0, 0)';
        });
      };
      
      // Use type assertion to fix TypeScript errors
      (parallaxContainer as HTMLElement).addEventListener('mousemove', handleMouseMove);
      (parallaxContainer as HTMLElement).addEventListener('touchmove', handleTouchMove);
      (parallaxContainer as HTMLElement).addEventListener('mouseleave', handleMouseLeave);
      (parallaxContainer as HTMLElement).addEventListener('touchend', handleTouchEnd);
      
      // Add cleanup function
      cleanupFunctions.push(() => {
        if (parallaxContainer) {
          (parallaxContainer as HTMLElement).removeEventListener('mousemove', handleMouseMove);
          (parallaxContainer as HTMLElement).removeEventListener('touchmove', handleTouchMove);
          (parallaxContainer as HTMLElement).removeEventListener('mouseleave', handleMouseLeave);
          (parallaxContainer as HTMLElement).removeEventListener('touchend', handleTouchEnd);
        }
      });
    }
  }

  // Particle Animation
  function initializeParticles() {
    const particlesContainer = document.querySelector('.particles-container');
    const particlesElement = document.querySelector('.particles');
    
    if (particlesContainer && particlesElement) {
      const createParticles = () => {
        particlesElement.innerHTML = '';
        const containerRect = particlesContainer.getBoundingClientRect();
        
        // Reduce particle count on mobile
        const particleCount = window.innerWidth < 768 ? 15 : 30;
        
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.classList.add('particle');
          
          const size = Math.random() * 6 + 2;
          const x = Math.random() * containerRect.width;
          const y = Math.random() * containerRect.height;
          const duration = Math.random() * 2 + 1;
          const delay = Math.random() * 0.5;
          
          particle.style.cssText = `
            position: absolute;
            width: ${size}px;
            height: ${size}px;
            background-color: var(--tw-color-primary-400, #a78bfa);
            border-radius: 50%;
            left: ${x}px;
            top: ${y}px;
            opacity: 0;
            animation: float ${duration}s ease-in-out ${delay}s infinite alternate;
          `;
          
          particlesElement.appendChild(particle);
        }
      };
      
      createParticles();
      
      // Add touch support
      const handleTouch = () => {
        (particlesContainer as HTMLElement).classList.add('active');
        setTimeout(() => {
          (particlesContainer as HTMLElement).classList.remove('active');
        }, 1000);
      };
      
      (particlesContainer as HTMLElement).addEventListener('touchstart', handleTouch);
      
      // Add animation keyframes
      const style = document.createElement('style');
      style.textContent = `
        @keyframes float {
          0% {
            transform: translateY(0) translateX(0);
            opacity: 0;
          }
          50% {
            opacity: 0.8;
          }
          100% {
            transform: translateY(-20px) translateX(10px);
            opacity: 0;
          }
        }
        
        .particles-container.active .particles {
          opacity: 1;
        }
      `;
      document.head.appendChild(style);
      
      // Add cleanup function
      cleanupFunctions.push(() => {
        if (style && document.head.contains(style)) {
          document.head.removeChild(style);
        }
        
        if (particlesContainer) {
          (particlesContainer as HTMLElement).removeEventListener('touchstart', handleTouch);
        }
      });
    }
  }

  // Interactive Demo Canvas
  function initializeCanvas() {
    const canvas = document.getElementById('demo-canvas') as HTMLCanvasElement;
    const demoButton = document.getElementById('demo-button') as HTMLButtonElement;
    
    if (canvas && demoButton) {
      const ctx = canvas.getContext('2d');
      let isActive = false;
      let particles: Array<Particle> = [];
      let animationFrameId: number | null = null;
      
      // Resize canvas to match container
      const resizeCanvas = () => {
        const container = canvas.parentElement;
        if (container) {
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
        }
      };
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Particle class
      class Particle {
        x: number;
        y: number;
        size: number;
        color: string;
        speedX: number;
        speedY: number;
        life: number;
        
        constructor(x: number, y: number, color?: string) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2;
          this.color = color || `hsl(${Math.random() * 60 + 240}, 70%, 60%)`;
          this.speedX = Math.random() * 3 - 1.5;
          this.speedY = Math.random() * 3 - 1.5;
          this.life = 100;
        }
        
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.life -= 1;
          
          if (this.size > 0.2) this.size -= 0.1;
        }
        
        draw() {
          if (ctx) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Animation loop
      function animate() {
        if (!isActive) return;
        
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
            
            if (particles[i].life <= 0 || particles[i].size <= 0.2) {
              particles.splice(i, 1);
              i--;
            }
          }
        }
        
        animationFrameId = requestAnimationFrame(animate);
      }
      
      // Event listeners
      const handleButtonClick = () => {
        isActive = !isActive;
        canvas.style.opacity = isActive ? '1' : '0.5';
        canvas.style.pointerEvents = isActive ? 'auto' : 'none';
        demoButton.textContent = isActive ? 'Deactivate Demo' : 'Activate Demo';
        
        if (isActive) {
          animate();
        } else if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
      };
      
      const handleMouseMove = (e: MouseEvent) => {
        if (!isActive) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        for (let i = 0; i < 3; i++) {
          particles.push(new Particle(x, y));
        }
      };
      
      const handleClick = (e: MouseEvent) => {
        if (!isActive) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        for (let i = 0; i < 20; i++) {
          particles.push(new Particle(x, y, `hsl(${Math.random() * 60 + 40}, 100%, 60%)`));
        }
      };
      
      demoButton.addEventListener('click', handleButtonClick);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('click', handleClick);
      
      // Add cleanup function
      cleanupFunctions.push(() => {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        
        window.removeEventListener('resize', resizeCanvas);
        
        if (demoButton) {
          demoButton.removeEventListener('click', handleButtonClick);
        }
        
        if (canvas) {
          canvas.removeEventListener('mousemove', handleMouseMove);
          canvas.removeEventListener('click', handleClick);
        }
        
        // Clear particles array
        particles = [];
      });
    }
  }
  
  // Initialize features on initial page load
  document.addEventListener('DOMContentLoaded', initializeFeatures);
  
  // Initialize features when navigating to this page with Astro's view transitions
  document.addEventListener('astro:page-load', initializeFeatures);
  
  // Cleanup when page is unloaded or before navigation
  document.addEventListener('astro:before-swap', () => {
    // Execute all cleanup functions
    cleanupFunctions.forEach(cleanup => cleanup());
    // Clear the array
    cleanupFunctions.length = 0;
  });
  
  // Also clean up on window unload as a fallback
  window.addEventListener('unload', () => {
    cleanupFunctions.forEach(cleanup => cleanup());
  });
</script>
